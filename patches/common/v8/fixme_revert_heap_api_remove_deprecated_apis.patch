From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samuel Attard <sattard@slack-corp.com>
Date: Thu, 21 Mar 2019 22:29:55 -0700
Subject: fixme: Revert "[heap,api] Remove deprecated APIs"

This reverts commit f4b860d9b81956fb9d6815932522f4043fef56fa.

This commit removes deprecated APIs that nan relies on, temporarily
reverting but we need to solve this with nan upstream

diff --git a/include/v8-internal.h b/include/v8-internal.h
index fe2ce67e0df04e58502d73ca5ac81a86ee001494..ed110be42bf4d7ab47bee480d8dbbfe547fbc423 100644
--- a/include/v8-internal.h
+++ b/include/v8-internal.h
@@ -174,6 +174,7 @@ class Internals {
   static const int kNodeStateMask = 0x7;
   static const int kNodeStateIsWeakValue = 2;
   static const int kNodeStateIsPendingValue = 3;
+  static const int kNodeStateIsNearDeathValue = 4;
   static const int kNodeIsIndependentShift = 3;
   static const int kNodeIsActiveShift = 4;
 
diff --git a/include/v8.h b/include/v8.h
index d2cf6f359bd614b2b41bcab8b5477564aeda2c38..765716334e660ea7d377f2ecc923a17d89f81033 100644
--- a/include/v8.h
+++ b/include/v8.h
@@ -576,6 +576,10 @@ template <class T> class PersistentBase {
 
   V8_DEPRECATED("See MarkIndependent.", V8_INLINE bool IsIndependent() const);
 
+  /** Checks if the handle holds the only reference to an object. */
+  V8_DEPRECATED("Garbage collection internal state should not be relied on.",
+                V8_INLINE bool IsNearDeath() const);
+
   /** Returns true if the handle's reference is weak.  */
   V8_INLINE bool IsWeak() const;
 
@@ -8544,6 +8548,17 @@ class V8_EXPORT Isolate {
    */
   void VisitHandlesWithClassIds(PersistentHandleVisitor* visitor);
 
+  /**
+   * Iterates through all the persistent handles in the current isolate's heap
+   * that have class_ids and are candidates to be marked as partially dependent
+   * handles. This will visit handles to young objects created since the last
+   * garbage collection but is free to visit an arbitrary superset of these
+   * objects.
+   */
+  V8_DEPRECATED(
+      "Use VisitHandlesWithClassIds",
+      void VisitHandlesForPartialDependence(PersistentHandleVisitor* visitor));
+
   /**
    * Iterates through all the persistent handles in the current isolate's heap
    * that have class_ids and are weak to be marked as inactive if there is no
@@ -9821,6 +9836,17 @@ bool PersistentBase<T>::IsIndependent() const {
                         I::kNodeIsIndependentShift);
 }
 
+template <class T>
+bool PersistentBase<T>::IsNearDeath() const {
+  typedef internal::Internals I;
+  if (this->IsEmpty()) return false;
+  uint8_t node_state =
+      I::GetNodeState(reinterpret_cast<internal::Address*>(this->val_));
+  return node_state == I::kNodeStateIsNearDeathValue ||
+      node_state == I::kNodeStateIsPendingValue;
+}
+
+
 template <class T>
 bool PersistentBase<T>::IsWeak() const {
   typedef internal::Internals I;
diff --git a/src/api/api.cc b/src/api/api.cc
index f2650d22a805897fa9453f69ff13e4bda556fc75..bbc0a49dcc9f82a7208c9bea417f403caabc74f6 100644
--- a/src/api/api.cc
+++ b/src/api/api.cc
@@ -8618,6 +8618,15 @@ void Isolate::VisitHandlesWithClassIds(PersistentHandleVisitor* visitor) {
   isolate->global_handles()->IterateAllRootsWithClassIds(visitor);
 }
 
+
+void Isolate::VisitHandlesForPartialDependence(
+    PersistentHandleVisitor* visitor) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+  i::DisallowHeapAllocation no_allocation;
+  isolate->global_handles()->IterateAllYoungRootsWithClassIds(visitor);
+}
+
+
 void Isolate::VisitWeakHandles(PersistentHandleVisitor* visitor) {
   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
   i::DisallowHeapAllocation no_allocation;
diff --git a/src/handles/global-handles.cc b/src/handles/global-handles.cc
index 53555911fc143347a3584bb70c655eee7c60e9c6..f4c35b53565d1feead39c0a9afd224ffd74ca3e3 100644
--- a/src/handles/global-handles.cc
+++ b/src/handles/global-handles.cc
@@ -380,6 +380,7 @@ class GlobalHandles::Node final : public NodeBase<GlobalHandles::Node> {
                   Internals::kNodeStateMask);
     STATIC_ASSERT(WEAK == Internals::kNodeStateIsWeakValue);
     STATIC_ASSERT(PENDING == Internals::kNodeStateIsPendingValue);
+    STATIC_ASSERT(NEAR_DEATH == Internals::kNodeStateIsNearDeathValue);
     STATIC_ASSERT(static_cast<int>(IsIndependent::kShift) ==
                   Internals::kNodeIsIndependentShift);
     STATIC_ASSERT(static_cast<int>(IsActive::kShift) ==
@@ -423,6 +424,11 @@ class GlobalHandles::Node final : public NodeBase<GlobalHandles::Node> {
     flags_ = NodeWeaknessType::update(flags_, weakness_type);
   }
 
+  bool IsNearDeath() const {
+    // Check for PENDING to ensure correct answer when processing callbacks.
+    return state() == PENDING || state() == NEAR_DEATH;
+  }
+
   bool IsWeak() const { return state() == WEAK; }
 
   bool IsInUse() const { return state() != FREE; }
@@ -810,6 +816,10 @@ void GlobalHandles::AnnotateStrongRetainer(Address* location,
   Node::FromLocation(location)->AnnotateStrongRetainer(label);
 }
 
+bool GlobalHandles::IsNearDeath(Address* location) {
+  return Node::FromLocation(location)->IsNearDeath();
+}
+
 bool GlobalHandles::IsWeak(Address* location) {
   return Node::FromLocation(location)->IsWeak();
 }
diff --git a/src/handles/global-handles.h b/src/handles/global-handles.h
index 245e9e78e137a614586a617c04f43b2b06ee8d2f..69932cfefc42c09c1baf11902cff2be5d2044fd5 100644
--- a/src/handles/global-handles.h
+++ b/src/handles/global-handles.h
@@ -73,6 +73,9 @@ class V8_EXPORT_PRIVATE GlobalHandles final {
   // Clear the weakness of a global handle.
   static void* ClearWeakness(Address* location);
 
+  // Tells whether global handle is near death.
+  static bool IsNearDeath(Address* location);
+
   // Tells whether global handle is weak.
   static bool IsWeak(Address* location);
 
diff --git a/test/cctest/heap/test-heap.cc b/test/cctest/heap/test-heap.cc
index 0172fa00c4fa6ce423501de807fe9dd0dd878b87..c4dc3bbd88959a92f96c9ac9d04eaeeebff25e37 100644
--- a/test/cctest/heap/test-heap.cc
+++ b/test/cctest/heap/test-heap.cc
@@ -527,9 +527,14 @@ TEST(WeakGlobalHandlesScavenge) {
 
   // Scavenge treats weak pointers as normal roots.
   CcTest::CollectGarbage(NEW_SPACE);
+
   CHECK((*h1)->IsString());
   CHECK((*h2)->IsHeapNumber());
+
   CHECK(!WeakPointerCleared);
+  CHECK(!global_handles->IsNearDeath(h2.location()));
+  CHECK(!global_handles->IsNearDeath(h1.location()));
+
   GlobalHandles::Destroy(h1.location());
   GlobalHandles::Destroy(h2.location());
 }
@@ -569,6 +574,8 @@ TEST(WeakGlobalUnmodifiedApiHandlesScavenge) {
   CcTest::CollectGarbage(NEW_SPACE);
   CHECK((*h1).IsHeapNumber());
   CHECK(WeakPointerCleared);
+  CHECK(!global_handles->IsNearDeath(h1.location()));
+
   GlobalHandles::Destroy(h1.location());
 }
 
@@ -605,7 +612,10 @@ TEST(WeakGlobalApiHandleModifiedMapScavenge) {
       &TestWeakGlobalHandleCallback, v8::WeakCallbackType::kParameter);
 
   CcTest::CollectGarbage(NEW_SPACE);
+
   CHECK(!WeakPointerCleared);
+  CHECK(!global_handles->IsNearDeath(h1.location()));
+
   GlobalHandles::Destroy(h1.location());
 }
 
@@ -646,7 +656,10 @@ TEST(WeakGlobalApiHandleWithElementsScavenge) {
       &TestWeakGlobalHandleCallback, v8::WeakCallbackType::kParameter);
 
   CcTest::CollectGarbage(NEW_SPACE);
+
   CHECK(!WeakPointerCleared);
+  CHECK(!global_handles->IsNearDeath(h1.location()));
+
   GlobalHandles::Destroy(h1.location());
 }
 
@@ -681,11 +694,15 @@ TEST(WeakGlobalHandlesMark) {
   GlobalHandles::MakeWeak(
       h2.location(), reinterpret_cast<void*>(&handle_and_id),
       &TestWeakGlobalHandleCallback, v8::WeakCallbackType::kParameter);
+  CHECK(!GlobalHandles::IsNearDeath(h1.location()));
+  CHECK(!GlobalHandles::IsNearDeath(h2.location()));
 
   // Incremental marking potentially marked handles before they turned weak.
   CcTest::CollectAllGarbage();
   CHECK((*h1).IsString());
   CHECK(WeakPointerCleared);
+  CHECK(!GlobalHandles::IsNearDeath(h1.location()));
+
   GlobalHandles::Destroy(h1.location());
 }
 
diff --git a/test/cctest/test-api.cc b/test/cctest/test-api.cc
index 168b5a3725c099d0607ff22ccc2cad3123233ab6..8ee65c2c482c3d268eff638b223e260308551ca2 100644
--- a/test/cctest/test-api.cc
+++ b/test/cctest/test-api.cc
@@ -19812,6 +19812,43 @@ TEST(WrapperClassId) {
   object.Reset();
 }
 
+
+TEST(PersistentHandleInNewSpaceVisitor) {
+  LocalContext context;
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::HandleScope scope(isolate);
+  v8::Persistent<v8::Object> object1(isolate, v8::Object::New(isolate));
+  CHECK_EQ(0, object1.WrapperClassId());
+  object1.SetWrapperClassId(42);
+  CHECK_EQ(42, object1.WrapperClassId());
+
+  CcTest::CollectAllGarbage();
+  CcTest::CollectAllGarbage();
+
+  v8::Persistent<v8::Object> object2(isolate, v8::Object::New(isolate));
+  CHECK_EQ(0, object2.WrapperClassId());
+  object2.SetWrapperClassId(42);
+  CHECK_EQ(42, object2.WrapperClassId());
+
+  Visitor42 visitor(&object2);
+#if __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated"
+#endif
+  // VisitHandlesForPartialDependence is marked deprecated. This test will be
+  // removed with the API method.
+  isolate->VisitHandlesForPartialDependence(&visitor);
+#if __clang__
+#pragma clang diagnostic pop
+#endif
+
+  CHECK_EQ(1, visitor.counter_);
+
+  object1.Reset();
+  object2.Reset();
+}
+
+
 TEST(RegExp) {
   LocalContext context;
   v8::HandleScope scope(context->GetIsolate());
